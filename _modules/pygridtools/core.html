

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pygridtools.core &mdash; pygridtools 0.2.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="pygridtools 0.2.1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../index.html" class="fa fa-home"> pygridtools</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/01_GridgenBasics.html">Grid Generation Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/01_GridgenBasics.html#load-and-plot-the-boundary-data">Load and plot the boundary data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/01_GridgenBasics.html#generate-a-grid-with-pygridgen-plot-it-with-pygridtools">Generate a grid with <code class="docutils literal"><span class="pre">pygridgen</span></code>, plot it with <code class="docutils literal"><span class="pre">pygridtools</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/01_GridgenBasics.html#now-numerically-add-focus-the-side-channels-and-coarsen-the-upper-portion">Now numerically add focus the side channels, and coarsen the upper portion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html">Masking grid cells</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#masking-basics">Masking basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#load-a-grid-boundary-river-and-set-of-islands-using-pygridtools-io">Load a grid boundary, river, and set of islands using <code class="docutils literal"><span class="pre">pygridtools.io</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#create-a-gridgen-object-and-convert-to-a-modelgrid">Create a <code class="docutils literal"><span class="pre">Gridgen</span></code> object and convert to a <code class="docutils literal"><span class="pre">ModelGrid</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#show-the-raw-unmasked-grid">Show the raw (unmasked) grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#mask-out-everything-beyond-the-river-banks">Mask out everything beyond the river banks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#loop-through-and-mask-out-the-islands">Loop through and mask out the islands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#export-the-masked-cells-to-a-shapefile">Export the masked cells to a shapefile</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/02_ShapefilesAndCellMasks.html#view-the-final-input-and-output-in-the-qgis-file-in-examples-masking-data-grid-qgs">View the final input and output in the QGIS file in <code class="docutils literal"><span class="pre">examples/masking_data/Grid.qgs</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html">Grid Manipulations (merge, split, refine, transform)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#notes">Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#create-3-model-grids-moving-counter-clockwise-in-the-axis">Create 3 model grids moving counter-clockwise in the axis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#display-positions-of-grids-relative-to-each-other">Display positions of grids relative to each other</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#merge-grids-1-and-2-together-horizontally">Merge grids 1 and 2 together, horizontally</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#use-the-shift-parameter-to-center-grid-2">Use the shift parameter to center grid 2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#vertically-merge-grid-2-and-grid-3">Vertically merge grid 2 and grid 3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#try-again-switching-the-order-of-the-grids">Try again, switching the order of the grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#alternatively-you-can-switch-the-arguments-and-use-where-to-indicate-that-the-other-grid-is-below-the-first">Alternatively, you can switch the arguments and use <code class="docutils literal"><span class="pre">where='-'</span></code> to indicate that the &#8220;other&#8221; grid is below the first.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#now-merge-all-three-in-a-single-chained-operation-inplace-false">Now merge all three in a single chained operation (<code class="docutils literal"><span class="pre">inplace=False</span></code>).</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#split-the-final-grid-into-two-vertical-parts">Split the final grid into two vertical parts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#split-the-final-grid-into-two-horizontal-parts">Split the final grid into two horizontal parts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#refine-individual-rows-of-the-grid-cells">Refine individual rows of the grid cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#refine-individual-columns-of-the-grid-cells">Refine individual columns of the grid cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial/03_MergingSpliting.html#one-big-chained-operation-for-fun">One big chained operation for fun</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/core.html">The <cite>core</cite> API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/iotools.html">The <cite>iotools</cite> API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/misc.html">The <cite>misc</cite> API</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">pygridtools</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>pygridtools.core</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for pygridtools.core</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="kn">from</span> <span class="nn">pygridtools</span> <span class="kn">import</span> <span class="n">misc</span>
<span class="kn">from</span> <span class="nn">pygridtools</span> <span class="kn">import</span> <span class="n">iotools</span>
<span class="kn">from</span> <span class="nn">pygridtools</span> <span class="kn">import</span> <span class="n">viz</span>


<div class="viewcode-block" id="transform"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.transform">[docs]</a><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">fxn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply an arbitrary function to an array of node coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes : numpy.ndarray</span>
<span class="sd">        An N x M array of individual node coordinates (i.e., the</span>
<span class="sd">        x-coords or the y-coords only)</span>
<span class="sd">    fxn : callable</span>
<span class="sd">        The transformation to be applied to the whole ``nodes`` array</span>
<span class="sd">    args, kwargs</span>
<span class="sd">        Additional positional and keyword arguments that are passed to</span>
<span class="sd">        ``fxn``. The final call will be ``fxn(nodes, *args, **kwargs)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transformed : numpy.ndarray</span>
<span class="sd">        The transformed array.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">fxn</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.split">[docs]</a><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a array of nodes into two separate, non-overlapping arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes : numpy.ndarray</span>
<span class="sd">        An N x M array of individual node coordinates (i.e., the</span>
<span class="sd">        x-coords or the y-coords only)</span>
<span class="sd">    index : int</span>
<span class="sd">        The leading edge of where the split should occur.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which ``nodes`` will be split. Use `axis = 0`</span>
<span class="sd">        to split along rows and `axis = 1` for columns.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Trying to split ``nodes`` at the edge (i.e., resulting in the</span>
<span class="sd">        original array and an empty array) will raise an error.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n1, n2 : numpy.ndarrays</span>
<span class="sd">        The two non-overlapping sides of the original array.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot split grid at or beyond its edges&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:</span><span class="n">index</span><span class="p">,</span> <span class="p">:],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">:,</span> <span class="p">:]</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="p">:</span><span class="n">index</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="n">index</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span>

</div>
<div class="viewcode-block" id="merge"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.merge">[docs]</a><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">other_nodes</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s">&#39;vert&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge two sets of nodes together.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes, other_nodes : numpy.ndarrays</span>
<span class="sd">        The sets of nodes that will be merged.</span>
<span class="sd">    how : string, optional (default = &#39;vert&#39;)</span>
<span class="sd">        The method through wich the arrays should be stacked.</span>
<span class="sd">        `&#39;Vert&#39;` is analogous to `np.vstack`. `&#39;Horiz&#39;` maps to</span>
<span class="sd">        `np.hstack`.</span>
<span class="sd">    where : string, optional (default = &#39;+&#39;)</span>
<span class="sd">        The placement of the arrays relative to each other. Keeping</span>
<span class="sd">        in mind that the origin of an array&#39;s index is in the</span>
<span class="sd">        upper-left corner, `&#39;+&#39;` indicates that the second array</span>
<span class="sd">        will be placed at higher index relative to the first array.</span>
<span class="sd">        Essentially</span>

<span class="sd">        - if how == &#39;vert&#39;</span>

<span class="sd">          - `&#39;+&#39;` -&gt; `a` is above (higher index) `b`</span>
<span class="sd">          - `&#39;-&#39;` -&gt; `a` is below (lower index) `b`</span>

<span class="sd">        - if how == &#39;horiz&#39;</span>

<span class="sd">          - `&#39;+&#39;` -&gt; `a` is to the left of `b`</span>
<span class="sd">          - `&#39;-&#39;` -&gt; `a` is to the right of `b`</span>

<span class="sd">        See the examples and :func:~`pygridtools.misc.padded_stack` for</span>
<span class="sd">        more info.</span>
<span class="sd">    shift : int, optional (default = 0)</span>
<span class="sd">        The number of indices the second array should be shifted in</span>
<span class="sd">        axis other than the one being merged. In other words,</span>
<span class="sd">        vertically stacked arrays can be shifted horizontally,</span>
<span class="sd">        and horizontally stacked arrays can be shifted vertically.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    merged : numpy.ndarrays</span>
<span class="sd">        The unified nodes coordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">transform</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">misc</span><span class="o">.</span><span class="n">padded_stack</span><span class="p">,</span> <span class="n">other_nodes</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                     <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_interp_between_vectors</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n_points</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;number of interpolated points must be at least 1&quot;</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">old_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">old_index</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">)</span>

    <span class="n">new_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_points</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


<div class="viewcode-block" id="refine"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.refine">[docs]</a><span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert and linearly interpolate new nodes in an existing array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes : numpy.ndarray</span>
<span class="sd">        An N x M array of individual node coordinates (i.e., the</span>
<span class="sd">        x-coords or the y-coords only)</span>
<span class="sd">    index : int</span>
<span class="sd">        The leading edge of where the split should occur.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which ``nodes`` will be split. Use `axis = 0`</span>
<span class="sd">        to split along rows and `axis = 1` for columns.</span>
<span class="sd">    n_points : int, optional</span>
<span class="sd">        The number of *new* rows or columns to be inserted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    refined : numpy.ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">refined</span> <span class="o">=</span> <span class="n">refine</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">bottom</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="n">_interp_between_vectors</span><span class="p">(</span><span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">)</span>
        <span class="n">refined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">top</span><span class="p">,</span> <span class="n">middle</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bottom</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">refined</span>

</div>
<div class="viewcode-block" id="ModelGrid"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid">[docs]</a><span class="k">class</span> <span class="nc">ModelGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for a curvilinear-orthogonal grid. Provides convenient</span>
<span class="sd">    access to masking, manipulation, and visualization methods.</span>

<span class="sd">    Although a good effort attempt is made to be consistent with the</span>
<span class="sd">    terminology, in general *node* and *vertex* are used</span>
<span class="sd">    interchangeably, with the former prefered over the latter.</span>
<span class="sd">    Similarly, *centroids* and *cells* can be interchangeable, although</span>
<span class="sd">    they are different. (Cell = the polygon created by 4 adjacent nodes</span>
<span class="sd">    and centroid = the centroid point of a cell).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes_x, nodes_y : numpy.ndarray</span>
<span class="sd">        M-by-N arrays of node (vertex) coordinates for the grid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_x</span><span class="p">,</span> <span class="n">nodes_y</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nodes_x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">nodes_y</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;input arrays must have the same shape&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodes_x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodes_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_template</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_islands</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of node x-coordinates. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_x</span>
    <span class="nd">@nodes_x.setter</span>
    <span class="k">def</span> <span class="nf">nodes_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Array of node y-coordinates. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_y</span>
    <span class="nd">@nodes_y.setter</span>
    <span class="k">def</span> <span class="nf">nodes_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array object of y-nodes&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_y</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cells_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of cell centroid x-coordinates&quot;&quot;&quot;</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">xc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cells_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array of cell centroid y-coordinates&quot;&quot;&quot;</span>
        <span class="n">yc</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yn</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">yn</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yn</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">yn</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">yc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Shape of the nodes arrays &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_x</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Shape of the cells arrays &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells_x</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut to x-coords of nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut to y-coords of nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Shortcut to x-coords of cells/centroids&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Shortcut to y-coords of cells/centroids&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells_y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">icells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of rows of cells&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">jcells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of columns of cells&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of rows of nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">jnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of columns of nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Boolean mask for the cells &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_mask</span>
    <span class="nd">@cell_mask.setter</span>
    <span class="k">def</span> <span class="nf">cell_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell_mask</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">template</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Template shapefile (schema) for export &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_template</span>
    <span class="nd">@template.setter</span>
    <span class="k">def</span> <span class="nf">template</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_template</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The optional domain used to generate the raw grid &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span>
    <span class="nd">@domain.setter</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The final extent of the model grid</span>
<span class="sd">        (everything outside is masked). &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span>
    <span class="nd">@extent.setter</span>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extent</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">islands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Polygons used to make holes/gaps in the grid &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_islands</span>
    <span class="nd">@islands.setter</span>
    <span class="k">def</span> <span class="nf">islands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_islands</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="ModelGrid.transform"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fxn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply an attribrary function to the grid nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fxn : callable</span>
<span class="sd">            The function to be applied to the nodes. It should accept</span>
<span class="sd">            a node array as its first argument.</span>

<span class="sd">            .. note:</span>
<span class="sd">               The function is applied to each node array (x and y)</span>
<span class="sd">               individually.</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Toggles the application of ``fxn`` in-place or on a copy.</span>
<span class="sd">        arg, kwargs : optional arguments and keyword arguments</span>
<span class="sd">            Additional values passed to ``fxn`` after the node array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or ModelGrid</span>
<span class="sd">            `None` is returned if ``inplace`` is `True`. Otherwise,</span>
<span class="sd">            a new :class:`~ModelGrid` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;inplace&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">nodes_x</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_x</span><span class="p">,</span> <span class="n">fxn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">nodes_y</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_y</span><span class="p">,</span> <span class="n">fxn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_x</span> <span class="o">=</span> <span class="n">nodes_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_y</span> <span class="o">=</span> <span class="n">nodes_y</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ModelGrid</span><span class="p">(</span><span class="n">nodes_x</span><span class="p">,</span> <span class="n">nodes_y</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.transpose"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transposes the node arrays of the model grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Toggles the application of ``fxn`` in-place or on a copy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or ModelGrid</span>
<span class="sd">            `None` is returned if ``inplace`` is `True`. Otherwise,</span>
<span class="sd">            a new :class:`~ModelGrid` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.fliplr"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.fliplr">[docs]</a>    <span class="k">def</span> <span class="nf">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverses the columns of the node arrays of the model grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Toggles the application of ``fxn`` in-place or on a copy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or ModelGrid</span>
<span class="sd">            `None` is returned if ``inplace`` is `True`. Otherwise,</span>
<span class="sd">            a new :class:`~ModelGrid` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.flipud"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.flipud">[docs]</a>    <span class="k">def</span> <span class="nf">flipud</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverses the rows of the node arrays of the model grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Toggles the application of ``fxn`` in-place or on a copy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or ModelGrid</span>
<span class="sd">            `None` is returned if ``inplace`` is `True`. Otherwise,</span>
<span class="sd">            a new :class:`~ModelGrid` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.split"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a model grid into two separate objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            The leading edge of where the split should occur.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            The axis along which ``nodes`` will be split. Use `axis = 0`</span>
<span class="sd">            to split along rows and `axis = 1` for columns.</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Toggles the application of ``fxn`` in-place or on a copy.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Trying to split at the edge (i.e., resulting in the</span>
<span class="sd">            original array and an empty array) will raise an error.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grid1, grid2 : ModelGrids</span>
<span class="sd">            The two non-overlapping sides of the grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_x</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_y</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ModelGrid</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">ModelGrid</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.refine"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.refine">[docs]</a>    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert and linearly interpolate new nodes in an existing grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : numpy.ndarray</span>
<span class="sd">            An N x M array of individual node coordinates (i.e., the</span>
<span class="sd">            x-coords or the y-coords only)</span>
<span class="sd">        index : int</span>
<span class="sd">            The leading edge of where the split should occur.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            The axis along which ``nodes`` will be split. Use `axis = 0`</span>
<span class="sd">            to split along rows and `axis = 1` for columns.</span>
<span class="sd">        n_points : int, optional</span>
<span class="sd">            The number of *new* rows or columns to be inserted.</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Toggles the application of ``fxn`` in-place or on a copy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or ModelGrid</span>
<span class="sd">            `None` is returned if ``inplace`` is `True`. Otherwise,</span>
<span class="sd">            a new :class:`~ModelGrid` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">refine</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.merge"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s">&#39;vert&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge with another grid using pygridtools.misc.padded_stack.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : ModelGrid</span>
<span class="sd">            The other ModelGrid object.</span>
<span class="sd">        how : optional string (default = &#39;vert&#39;)</span>
<span class="sd">            The method through wich the arrays should be stacked.</span>
<span class="sd">            `&#39;Vert&#39;` is analogous to `np.vstack`. `&#39;Horiz&#39;` maps to</span>
<span class="sd">            `np.hstack`.</span>
<span class="sd">        where : optional string (default = &#39;+&#39;)</span>
<span class="sd">            The placement of the arrays relative to each other. Keeping</span>
<span class="sd">            in mind that the origin of an array&#39;s index is in the</span>
<span class="sd">            upper-left corner, `&#39;+&#39;` indicates that the second array</span>
<span class="sd">            will be placed at higher index relative to the first array.</span>
<span class="sd">            Essentially:</span>

<span class="sd">             - if how == &#39;vert&#39;</span>

<span class="sd">               - `&#39;+&#39;` -&gt; `a` is above (higher index) `b`</span>
<span class="sd">               - `&#39;-&#39;` -&gt; `a` is below (lower index) `b`</span>

<span class="sd">             - if how == &#39;horiz&#39;</span>

<span class="sd">               - `&#39;+&#39;` -&gt; `a` is to the left of `b`</span>
<span class="sd">               - `&#39;-&#39;` -&gt; `a` is to the right of `b`</span>

<span class="sd">            See the examples and pygridtools.misc.padded_stack for more</span>
<span class="sd">            info.</span>
<span class="sd">        shift : int (default = 0)</span>
<span class="sd">            The number of indices the second array should be shifted in</span>
<span class="sd">            axis other than the one being merged. In other words,</span>
<span class="sd">            vertically stacked arrays can be shifted horizontally,</span>
<span class="sd">            and horizontally stacked arrays can be shifted vertically.</span>
<span class="sd">        inplace : bool, optional</span>
<span class="sd">            Toggles the application of ``fxn`` in-place or on a copy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or ModelGrid</span>
<span class="sd">            `None` is returned if ``inplace`` is `True`. Otherwise,</span>
<span class="sd">            a new :class:`~ModelGrid` is returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The ``cell_mask`` attribute is not automatically updated</span>
<span class="sd">        following merge operates. See the Examples section on handling</span>
<span class="sd">        this manually.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; domain1 = pandas.DataFrame({</span>
<span class="sd">            &#39;x&#39;: [2, 5, 5, 2],</span>
<span class="sd">            &#39;y&#39;: [6, 6, 4, 4],</span>
<span class="sd">            &#39;beta&#39;: [1, 1, 1, 1]</span>
<span class="sd">        })</span>
<span class="sd">        &gt;&gt;&gt; domain2 = pandas.DataFrame({</span>
<span class="sd">            &#39;x&#39;: [6, 11, 11, 5],</span>
<span class="sd">            &#39;y&#39;: [5, 5, 3, 3],</span>
<span class="sd">            &#39;beta&#39;: [1, 1, 1, 1]</span>
<span class="sd">        })</span>
<span class="sd">        &gt;&gt;&gt; grid1 = pgt.makeGrid(domain=domain1, nx=6, ny=5, rawgrid=False)</span>
<span class="sd">        &gt;&gt;&gt; grid2 = pgt.makeGrid(domain=domain2, nx=8, ny=7, rawgrid=False)</span>
<span class="sd">        &gt;&gt;&gt; grid1.merge(grid2, how=&#39;horiz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # update the cell mask to include new NA points:</span>
<span class="sd">        &gt;&gt;&gt; grid1.cell_mask = np.ma.masked_invalid(grid1.xc).mask</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pygridtools.padded_stack</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes_x</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_x</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes_x</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>
        <span class="n">nodes_y</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_y</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes_y</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_x</span> <span class="o">=</span> <span class="n">nodes_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_y</span> <span class="o">=</span> <span class="n">nodes_y</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ModelGrid</span><span class="p">(</span><span class="n">nodes_x</span><span class="p">,</span> <span class="n">nodes_y</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.update_cell_mask"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.update_cell_mask">[docs]</a>    <span class="k">def</span> <span class="nf">update_cell_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Regenerate the cell mask based on either the NaN cells</span>
<span class="sd">        or a user-provided mask. This is usefull after splitting,</span>
<span class="sd">        merging, or anything other transformation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : numpy.ndarray of bools, optional</span>
<span class="sd">            The custom make to apply. If ommited, the mask will be</span>
<span class="sd">            determined by the missing values in the cells arrays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">            So you can method-chain this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xc</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="ModelGrid.mask_cells_with_polygon"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.mask_cells_with_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">mask_cells_with_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyverts</span><span class="p">,</span> <span class="n">use_centroids</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                <span class="n">min_nodes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">inside</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                <span class="n">use_existing</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">triangles</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; Create mask for the cells of the ModelGrid with a polygon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        polyverts : sequence of a polygon&#39;s vertices</span>
<span class="sd">            A sequence of x-y pairs for each vertex of the polygon.</span>
<span class="sd">        use_centroids : bool (default = True)</span>
<span class="sd">            When True, the cell centroid will be used to determine</span>
<span class="sd">            whether the cell is &quot;inside&quot; the polygon. If False, the</span>
<span class="sd">            nodes are used instead.</span>
<span class="sd">        min_nodes : int (default = 3)</span>
<span class="sd">            Only used when ``use_centroids`` is False. This is the</span>
<span class="sd">            minimum number of nodes inside the polygon required to mark</span>
<span class="sd">            the cell as &quot;inside&quot;. Must be greater than 0, but no more</span>
<span class="sd">            than 4.</span>
<span class="sd">        inside : bool (default = True)</span>
<span class="sd">            Toggles masking of cells either *inside* (True) or *outside*</span>
<span class="sd">            (False) the polygon.</span>
<span class="sd">        triangles : bool</span>
<span class="sd">            Not yet implemented.</span>
<span class="sd">        use_existing : bool (default = True)</span>
<span class="sd">            When True, the newly computed mask is combined (via a</span>
<span class="sd">            bit-wise `or` operation) with the existing ``cell_mask``</span>
<span class="sd">            attribute of the MdoelGrid.</span>
<span class="sd">        inplace : bool (default = True):</span>
<span class="sd">            If True, the ``cell_mask`` attribute of the ModelGrid is set</span>
<span class="sd">            to the returned masked and None is returned. Otherwise, the</span>
<span class="sd">            a new mask is returned the ``cell_mask`` attribute of the</span>
<span class="sd">            ModelGrid is unchanged.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cell_mask : np.array of bools</span>
<span class="sd">            The final mask to be applied to the cells of the ModelGrid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">triangles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;triangles are not yet implemented.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_centroids</span><span class="p">:</span>
            <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">mask_with_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yc</span><span class="p">,</span> <span class="n">polyverts</span><span class="p">,</span> <span class="n">inside</span><span class="o">=</span><span class="n">inside</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_nodes</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">min_nodes</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`min_nodes` must be greater than 0 and no more than 4.&quot;</span><span class="p">)</span>

            <span class="n">_node_mask</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">mask_with_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yn</span><span class="p">,</span> <span class="n">polyverts</span><span class="p">,</span> <span class="n">inside</span><span class="o">=</span><span class="n">inside</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">cell_mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_node_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">_node_mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">_node_mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">_node_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_nodes</span>
            <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">cell_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_existing</span><span class="p">:</span>
            <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span><span class="p">,</span> <span class="n">cell_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span> <span class="o">=</span> <span class="n">cell_mask</span>

        <span class="k">return</span> <span class="n">cell_mask</span>
</div>
<div class="viewcode-block" id="ModelGrid.writeGEFDCControlFile"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.writeGEFDCControlFile">[docs]</a>    <span class="k">def</span> <span class="nf">writeGEFDCControlFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;gefdc.inp&#39;</span><span class="p">,</span>
                              <span class="n">bathyrows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;test&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the GEFDC control (gefdc.inp) file for the EFDC grid</span>
<span class="sd">        preprocessor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputdir : str, optional</span>
<span class="sd">            The path to where the should be saved.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The name of the output file.</span>
<span class="sd">        bathyrows : int, optional</span>
<span class="sd">            The number of rows in the grid&#39;s bathymetry data file.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            The title of the grid as portrayed in ``filename``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gefdc : str</span>
<span class="sd">            The text of the output file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">outfile</span> <span class="o">=</span> <span class="n">iotools</span><span class="o">.</span><span class="n">_outputfile</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="n">gefdc</span> <span class="o">=</span> <span class="n">iotools</span><span class="o">.</span><span class="n">_write_gefdc_control_file</span><span class="p">(</span>
            <span class="n">outfile</span><span class="p">,</span>
            <span class="n">title</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jnodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">bathyrows</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gefdc</span>
</div>
<div class="viewcode-block" id="ModelGrid.writeGEFDCCellFile"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.writeGEFDCCellFile">[docs]</a>    <span class="k">def</span> <span class="nf">writeGEFDCCellFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;cell.inp&#39;</span><span class="p">,</span>
                           <span class="n">triangles</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">maxcols</span><span class="o">=</span><span class="mi">125</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the cell definition/ASCII-art file for GEFDC.</span>

<span class="sd">        .. warning:</span>
<span class="sd">           This whole thing is probably pretty buggy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputdir : str, optional</span>
<span class="sd">            The path to where the should be saved.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The name of the output file.</span>
<span class="sd">        triangles : bool, optional</span>
<span class="sd">            Toggles the inclusion of triangular cells.</span>

<span class="sd">            .. warning:</span>
<span class="sd">               This is experimental and probably buggy if it has been</span>
<span class="sd">               implmented at all.</span>

<span class="sd">        maxcols : int, optional</span>
<span class="sd">            The maximum number of columns to write to each row. Cells</span>
<span class="sd">            beyond this number will be writted in separate section at</span>
<span class="sd">            the bottom of the file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cells : str</span>
<span class="sd">            The text of the output file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cells</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">make_gefdc_cells</span><span class="p">(</span>
            <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span><span class="p">,</span> <span class="n">triangles</span><span class="o">=</span><span class="n">triangles</span>
        <span class="p">)</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">iotools</span><span class="o">.</span><span class="n">_outputfile</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="n">iotools</span><span class="o">.</span><span class="n">_write_cellinp</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">outputfile</span><span class="o">=</span><span class="n">outfile</span><span class="p">,</span>
                               <span class="n">flip</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">maxcols</span><span class="o">=</span><span class="n">maxcols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cells</span>
</div>
<div class="viewcode-block" id="ModelGrid.writeGEFDCGridFile"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.writeGEFDCGridFile">[docs]</a>    <span class="k">def</span> <span class="nf">writeGEFDCGridFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;grid.out&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes to the nodes as coordinate pairs for GEFDC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputdir : str, optional</span>
<span class="sd">            The path to where the should be saved.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The name of the output file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            The dataframe of node coordinate pairs.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">outfile</span> <span class="o">=</span> <span class="n">iotools</span><span class="o">.</span><span class="n">_outputfile</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">iotools</span><span class="o">.</span><span class="n">_write_gridout_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yn</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
</div>
<div class="viewcode-block" id="ModelGrid.writeGEFDCGridextFile"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.writeGEFDCGridextFile">[docs]</a>    <span class="k">def</span> <span class="nf">writeGEFDCGridextFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputdir</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;gridext.inp&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes to the nodes and I/J cell index as to a file for GEFDC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputdir : str, optional</span>
<span class="sd">            The path to where the should be saved.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The name of the output file.</span>
<span class="sd">        shift : int, optional</span>
<span class="sd">            The shift that should be applied to the I/J index. The</span>
<span class="sd">            default value to 2 means that the first cell is at (2, 2)</span>
<span class="sd">            instead of (0, 0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            The dataframe of coordinates and I/J index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="n">iotools</span><span class="o">.</span><span class="n">_outputfile</span><span class="p">(</span><span class="n">outputdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">df</span><span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shift</span>
        <span class="n">df</span><span class="p">[</span><span class="s">&#39;j&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shift</span>
        <span class="n">iotools</span><span class="o">.</span><span class="n">_write_gridext_file</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
</div>
<div class="viewcode-block" id="ModelGrid.plotCells"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.plotCells">[docs]</a>    <span class="k">def</span> <span class="nf">plotCells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s">&#39;mpl&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">usemask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cell_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">domain_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extent_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">showisland</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">island_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a figure of the cells, boundary, domain, and islands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        engine : str</span>
<span class="sd">            The plotting engine to be used. Right now, only `&#39;mpl&#39;` has</span>
<span class="sd">            been implemented. Interactive figures via `&#39;bokeh&#39;` are</span>
<span class="sd">            planned.</span>
<span class="sd">        ax : matplotlib.Axes, optional</span>
<span class="sd">            The axes onto which the data will be drawn. If not provided,</span>
<span class="sd">            a new one will be created. Applies only to the *mpl* engine.</span>
<span class="sd">        usemask : bool, optional</span>
<span class="sd">            Whether or not cells should have the ModelGrid&#39;s mask</span>
<span class="sd">            applied to them.</span>
<span class="sd">        cell_kws, domain_kws, extent_kws, island_kws : dict</span>
<span class="sd">            Dictionaries of plotting options for each element</span>
<span class="sd">            of the figure.</span>

<span class="sd">            .. note:</span>
<span class="sd">            ``cell_kws`` and ``island_kws`` are feed to</span>
<span class="sd">            :func:`~matplotlib.pyplot.Polygon`. All others are sent</span>
<span class="sd">            to :meth:`~ax.plot`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">cell_kws</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cell_kws</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">plotCells</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yn</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                            <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span><span class="p">,</span> <span class="o">**</span><span class="n">cell_kws</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">domain_kws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">plotDomain</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">domain_kws</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extent_kws</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">plotBoundaries</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">extent_kws</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">island_kws</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">plotBoundaries</span><span class="p">(</span><span class="n">islands</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">islands</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">island_kws</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span>
</div>
    <span class="k">def</span> <span class="nf">_get_x_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">which</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;nodes&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can only mask cells, not nodes&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yn</span>

        <span class="k">elif</span> <span class="n">which</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;cells&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yc</span>
            <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;`which` must be either &quot;nodes&quot; or &quot;cells&quot;&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

<div class="viewcode-block" id="ModelGrid.to_dataframe"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;nodes&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a grid to a wide dataframe of coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        usemask : bool, optional</span>
<span class="sd">            Toggles the ommission of masked values (as determined by</span>
<span class="sd">            :meth:`~cell_mask`.</span>
<span class="sd">        which : str, optional (&#39;nodes&#39;)</span>
<span class="sd">            This can be &quot;nodes&quot; (default) or &quot;cells&quot;. Specifies which</span>
<span class="sd">            coordinates should be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x_y</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="n">usemask</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">make_cols</span><span class="p">(</span><span class="n">top_level</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">top_level</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;coord&#39;</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">columns</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;j&#39;</span><span class="p">)</span>
        <span class="n">easting_cols</span> <span class="o">=</span> <span class="n">make_cols</span><span class="p">(</span><span class="s">&#39;easting&#39;</span><span class="p">)</span>
        <span class="n">northing_cols</span> <span class="o">=</span> <span class="n">make_cols</span><span class="p">(</span><span class="s">&#39;northing&#39;</span><span class="p">)</span>

        <span class="n">easting</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">easting_cols</span><span class="p">)</span>
        <span class="n">northing</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">northing_cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">easting</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">northing</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelGrid.to_coord_pairs"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.to_coord_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">to_coord_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;nodes&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a grid to a long array of coordinates pairs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        usemask : bool, optional</span>
<span class="sd">            Toggles the ommission of masked values (as determined by</span>
<span class="sd">            :meth:`~cell_mask`.</span>
<span class="sd">        which : str, optional (&#39;nodes&#39;)</span>
<span class="sd">            This can be &quot;nodes&quot; (default) or &quot;cells&quot;. Specifies which</span>
<span class="sd">            coordinates should be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x_y</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="n">usemask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">())))</span>
</div>
<div class="viewcode-block" id="ModelGrid.to_shapefile"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.to_shapefile">[docs]</a>    <span class="k">def</span> <span class="nf">to_shapefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;cells&#39;</span><span class="p">,</span>
                     <span class="n">river</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reach</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">elev</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">geom</span><span class="o">=</span><span class="s">&#39;Polygon&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">triangles</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a grid to a shapefile via the *fiona* package.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputfile : str</span>
<span class="sd">            The name of the shapefile where the data will be saved.</span>
<span class="sd">        usemask : bool, optional</span>
<span class="sd">            Toggles the ommission of masked values (as determined by</span>
<span class="sd">            :meth:`~cell_mask`.</span>
<span class="sd">        which : str, optional</span>
<span class="sd">            This can be &quot;nodes&quot; (default) or &quot;cells&quot;. Specifies which</span>
<span class="sd">            coordinates should be used.</span>
<span class="sd">        river : str, optional</span>
<span class="sd">            Identifier of the river.</span>
<span class="sd">        reach : int or str, optional</span>
<span class="sd">            Indetifier of the reach of ``river``.</span>
<span class="sd">        elev : numpy.ndarray, optional</span>
<span class="sd">            Bathymetry data to be assigned to each record in the</span>
<span class="sd">            shapefile.</span>
<span class="sd">        template : str, optional</span>
<span class="sd">            The shapefile schema template. If not provided, the</span>
<span class="sd">            ``template`` attribute of the ModelGrid object is used.</span>
<span class="sd">        geom : str, optional</span>
<span class="sd">            The type of geometry to use. If &quot;Point&quot;, either the grid</span>
<span class="sd">            nodes or the centroids of the can be used (see the</span>
<span class="sd">            ``which`` parameter). However, if &quot;Polygon&quot; is specified,</span>
<span class="sd">            cells will be generated from the nodes, regardless of the</span>
<span class="sd">            value of ``which``.</span>
<span class="sd">        mode : str, optional</span>
<span class="sd">            The mode in which ``outputfile`` will be opened. Should be</span>
<span class="sd">            either &#39;w&#39; (write) or &#39;a&#39; (append).</span>
<span class="sd">        triangles : bool, optional</span>
<span class="sd">            Toggles the inclusion of triangular cells.</span>

<span class="sd">            .. warning:</span>
<span class="sd">               This is experimental and probably buggy if it has been</span>
<span class="sd">               implmented at all.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">template</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;point&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x_y</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="n">usemask</span><span class="p">)</span>
            <span class="n">iotools</span><span class="o">.</span><span class="n">savePointShapefile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">river</span><span class="o">=</span><span class="n">river</span><span class="p">,</span> <span class="n">reach</span><span class="o">=</span><span class="n">reach</span><span class="p">,</span>
                                       <span class="n">elev</span><span class="o">=</span><span class="n">elev</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">geom</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;cell&#39;</span><span class="p">,</span> <span class="s">&#39;cells&#39;</span><span class="p">,</span> <span class="s">&#39;grid&#39;</span><span class="p">,</span> <span class="s">&#39;polygon&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_x_y</span><span class="p">(</span><span class="s">&#39;nodes&#39;</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">iotools</span><span class="o">.</span><span class="n">saveGridShapefile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span>
                                      <span class="n">outputfile</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">river</span><span class="o">=</span><span class="n">river</span><span class="p">,</span>
                                      <span class="n">reach</span><span class="o">=</span><span class="n">reach</span><span class="p">,</span> <span class="n">elev</span><span class="o">=</span><span class="n">elev</span><span class="p">,</span>
                                      <span class="n">triangles</span><span class="o">=</span><span class="n">triangles</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s">&#39;cells&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;polygons always constructed from nodes&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;geom must be either &#39;Point&#39; or &#39;Polygon&#39;&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="ModelGrid.from_dataframe"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.from_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="s">&#39;easting&#39;</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="s">&#39;northing&#39;</span><span class="p">,</span> <span class="n">ilevel</span><span class="o">=</span><span class="s">&#39;ii&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a ModelGrid from a DataFrame of I/J indexes and x/y</span>
<span class="sd">        columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            Must have a MultiIndex of I/J cell index values.</span>
<span class="sd">        xcol, ycol : str, optional</span>
<span class="sd">            The names of the columns for the x and y coordinates.</span>
<span class="sd">        ilevel : str, optional</span>
<span class="sd">            The index level specifying the I-index of the grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ModelGrid</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes_x</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">xcol</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">ilevel</span><span class="p">)</span>
        <span class="n">nodes_y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">ycol</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">ilevel</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">nodes_x</span><span class="p">,</span> <span class="n">nodes_y</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="ModelGrid.from_shapefile"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.from_shapefile">[docs]</a>    <span class="k">def</span> <span class="nf">from_shapefile</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">shapefile</span><span class="p">,</span> <span class="n">icol</span><span class="o">=</span><span class="s">&#39;ii&#39;</span><span class="p">,</span> <span class="n">jcol</span><span class="o">=</span><span class="s">&#39;jj&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a ModelGrid from a shapefile of *nodes*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputfile : str</span>
<span class="sd">            The name of the shapefile of the grid *nodes*.</span>
<span class="sd">        icol, jcol : str, optional</span>
<span class="sd">            The names of the columns in the shapefile containing the</span>
<span class="sd">            I/J index of the nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ModelGrid</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">iotools</span><span class="o">.</span><span class="n">readGridShapefile</span><span class="p">(</span><span class="n">shapefile</span><span class="p">,</span> <span class="n">icol</span><span class="o">=</span><span class="n">icol</span><span class="p">,</span> <span class="n">jcol</span><span class="o">=</span><span class="n">jcol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dataframes</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">&#39;easting&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;northing&#39;</span><span class="p">])</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="ModelGrid.from_Gridgen"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.ModelGrid.from_Gridgen">[docs]</a>    <span class="k">def</span> <span class="nf">from_Gridgen</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">gridgen</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a ModelGrid from a :class:`~pygridgen.Gridgen` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gridgen : pygridgen.Gridgen</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ModelGrid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">gridgen</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">gridgen</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="makeGrid"><a class="viewcode-back" href="../../api/core.html#pygridtools.core.makeGrid">[docs]</a><span class="k">def</span> <span class="nf">makeGrid</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">bathydata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">rawgrid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">gparams</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a :class:`~pygridgen.Gridgen` or :class:`~ModelGrid`</span>
<span class="sd">    from scratch. This can take a large number of parameters passed</span>
<span class="sd">    directly to the ``Gridgen`` constructor. See the</span>
<span class="sd">    `Other Parameters` section.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ny, nx : int</span>
<span class="sd">        The number of rows and columns that will make up the grid&#39;s</span>
<span class="sd">        *nodes*. Note the final grid *cells* will be (ny-1) by (nx-1).</span>
<span class="sd">    domain : optional pandas.DataFrame or None (default)</span>
<span class="sd">        Defines the boundary of the model area. Must be provided if</span>
<span class="sd">        `makegrid` = True. Required columns:</span>

<span class="sd">          - &#39;x&#39; (easting)</span>
<span class="sd">          - &#39;y&#39; (northing),</span>
<span class="sd">          - &#39;beta&#39; (turning points, must sum to 1)</span>

<span class="sd">    bathydata : optional pandas.DataFrame or None (default)</span>
<span class="sd">        Point bathymetry/elevation data. Will be interpolated unto the</span>
<span class="sd">        grid if provided. If None, a default value of 0 will be used.</span>
<span class="sd">        Required columns:</span>

<span class="sd">          - &#39;x&#39; (easting)</span>
<span class="sd">          - &#39;y&#39; (northing),</span>
<span class="sd">          - &#39;z&#39; (elevation)</span>

<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Toggles on the printing of status updates.</span>
<span class="sd">    rawgrid : bool (default = True)</span>
<span class="sd">        When True, returns a pygridgen.Gridgen object. Otherwise, a</span>
<span class="sd">        pygridtools.ModelGrid object is returned.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    ul_idx : optional int (default = 0)</span>
<span class="sd">        The index of the what should be considered the upper left</span>
<span class="sd">        corner of the grid boundary in the `xbry`, `ybry`, and</span>
<span class="sd">        `beta` inputs. This is actually more arbitrary than it</span>
<span class="sd">        sounds. Put it some place convenient for you, and the</span>
<span class="sd">        algorthim will conceptually rotate the boundary to place</span>
<span class="sd">        this point in the upper left corner. Keep that in mind when</span>
<span class="sd">        specifying the shape of the grid.</span>
<span class="sd">    focus : optional pygridgen.Focus instance or None (default)</span>
<span class="sd">        A focus object to tighten/loosen the grid in certain</span>
<span class="sd">        sections.</span>
<span class="sd">    proj : option pyproj projection or None (default)</span>
<span class="sd">        A pyproj projection to be used to convert lat/lon</span>
<span class="sd">        coordinates to a projected (Cartesian) coordinate system</span>
<span class="sd">        (e.g., UTM, state plane).</span>
<span class="sd">    nnodes : optional int (default = 14)</span>
<span class="sd">        The number of nodes used in grid generation. This affects</span>
<span class="sd">        the precision and computation time. A rule of thumb is that</span>
<span class="sd">        this should be equal to or slightly larger than</span>
<span class="sd">        -log10(precision).</span>
<span class="sd">    precision : optional float (default = 1.0e-12)</span>
<span class="sd">        The precision with which the grid is generated. The default</span>
<span class="sd">        value is good for lat/lon coordinate (i.e., smaller</span>
<span class="sd">        magnitudes of boundary coordinates). You can relax this to</span>
<span class="sd">        e.g., 1e-3 when working in state plane or UTM grids and</span>
<span class="sd">        you&#39;ll typically get better performance.</span>
<span class="sd">    nppe : optional int (default = 3)</span>
<span class="sd">        The number of points per internal edge. Lower values will</span>
<span class="sd">        coarsen the image.</span>
<span class="sd">    newton : optional bool (default = True)</span>
<span class="sd">        Toggles the use of Gauss-Newton solver with Broyden update</span>
<span class="sd">        to determine the sigma values of the grid domains. If False</span>
<span class="sd">        simple iterations will be used instead.</span>
<span class="sd">    thin : optional bool (default = True)</span>
<span class="sd">        Toggle to True when the (some portion of) the grid is</span>
<span class="sd">        generally narrow in one dimension compared to another.</span>
<span class="sd">    checksimplepoly : optional bool (default = True)</span>
<span class="sd">        Toggles a check to confirm that the boundary inputs form a</span>
<span class="sd">        valid geometry.</span>
<span class="sd">    verbose : optional bool (default = True)</span>
<span class="sd">        Toggles the printing of console statements to track the</span>
<span class="sd">        progress of the grid generation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : pygridgen.Gridgen or ModelGrid</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If your boundary has a lot of points, this really can take quite</span>
<span class="sd">    some time. Setting verbose=True will help track the progress of the</span>
<span class="sd">    grid generattion.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pygridgen.Gridgen, pygridgen.csa, pygridtools.ModelGrid</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pygridgen</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&quot;`pygridgen` not installed. Cannot make grid.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;generating grid&#39;</span><span class="p">)</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">pygridgen</span><span class="o">.</span><span class="n">Gridgen</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="o">**</span><span class="n">gparams</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;interpolating bathymetry&#39;</span><span class="p">)</span>

    <span class="n">newbathy</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">interpolate_bathymetry</span><span class="p">(</span><span class="n">bathydata</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">x_rho</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">y_rho</span><span class="p">,</span>
                                           <span class="n">xcol</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="n">zcol</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rawgrid</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grid</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ModelGrid</span><span class="o">.</span><span class="n">from_Gridgen</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span></div>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Paul Hobson.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.2.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>